# Part 3 ‚Äî Making our applications more robust with schema generated types

## üß† Learning objectives

- Using types in vanilla JavaScript with JSDoc and TypeScript.
- How static type checking in vanilla JavaScript helps reduce bugs.
- TypeScript options for generating types from schemas.

## Copy over your work so far

```sh
cp 02-creating-flexible-validation-rules/routes.js 03-generated-schema-types/routes.js

cp -r 02-creating-flexible-validation-rules/schemas/ 03-generated-schema-types/
```

## Change into the directory for this part of the workshop

```sh
cd 03-generated-schema-types/
```

## Using types in vanilla JavaScript with JSDoc and TypeScript

You can combine generated types and JSDoc annotations to get type hinting and
static type checking in JavaScript.

The [json-schema-to-typescript](https://npm.im/json-schema-to-typescript) package
can take your JSON schemas and generate TypeScript type definitions for ypu.
It provides a library and a CLI. The CLI is pretty flexible, for example you can
point it at a directory full of schemas and it will generate the corresponding
type definitions files for all of them:

```bash
npx json2ts -i schemas/ -o types/
```

The following packages have been pre-installed as `devDependencies`:

- [json-schema-to-typescript](https://npm.im/json-schema-to-typescript)
- [typescript](https://www.npmjs.com/package/typescript)
- [@types/node](https://www.npmjs.com/package/@types/node) ‚Äî Node.js types.

Define some npm run scripts in [package.json](package.json):

```json
{
  "scripts": {
    "schema-types:generate": "json2ts -i schemas/ -o types/schemas/",
    "schema-types:clean": "rm -rf types/schemas/",
    "build:schema-types": "npm run schema-types:clean && npm run schema-types:generate"
  }
}
```

The script `build:schema-types` removes any existing generated types. It then
runs the `json-schema-to-typescript` CLI to generate a type definition file
from the recipe JSON schema.

When you run the script:

```bash
npm run build:schema-types
```

You'll see a file named [recipe.schema.d.ts](types/schemas/recipe.schema.d.ts) has been generated in the `types/schemas/`
directory. This contains a `RecipeSchema` TypeScript interface which has been
inferred from the recipe JSON schema:

```typescript
/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface RecipeSchema {
  name: string;
  ingredients: [string, ...string[]];
  time?: {
    preparation: number;
    cooking: number;
  };
}
```

Create a **"tsconfig.json"** file which configures the TypeScript compiler to
check your JavaScript code:

```json
{
  "compilerOptions": {
    "lib": ["es2020", "DOM"],
    "moduleResolution": "node",
    "module": "esnext",
    "allowJs": true,
    "checkJs": true,
    "noEmit": true,
    "strict": false
  },
  "include": ["*.js"],
  "exclude": ["node_modules"]
}
```

Add a couple more npm run scripts to [package.json](package.json):

```json
{
  "scripts": {
    "check-types": "tsc",
    "build": "npm run build:schema-types && npm run check-types"
  }
}
```

## üéØ Exercise 3.1

**Cause a type error in your application.**

- There is a `HandlerWithTypedBody` generic function type defined in [types/index.d.ts](types/index.d.ts).
- Add a JSDoc annotation, which uses the `HandlerWithTypedBody` and `RecipeSchema`
types, above the route handler function:

```diff
+ /** @type {import("./types").HandlerWithTypedBody<import("./types/schemas/recipe.schema").RecipeSchema>} */
  handler: async function (request, response) {
```

- Edit the existing `console.log` line so it contains a bug that causes a type error:

```javascript
console.log("Recipe ingredients:", recipe.ingredients.join(", "));
```

- Check your work by running:

```sh
npm run build
```

This will run the TypeScript compiler against you JavaScript code. It will
statically check the types in the code, and should alert you to a type error
in your code.

- Fix the issue you've introduced on the `console.log` line and check that
the type error has been resolved by running `npm run build`.

You now have automatic types from your recipe JSON schema, allowing you to type
check your JavaScript code.

<details>
  <summary><strong>Exercise hints (try without them to start with)</strong></summary>

  - `console.log("Recipe ingredients:", recipe.time.join(", "));`
</details>

<details>
  <summary><strong>Solution</strong></summary>

  You can see a passing solution in
  [completed/routes.exercise-3.1.completed.js](completed/routes.exercise-3.1.completed.js).
</details>

## TypeScript options for generating types from schemas

If you're writing your Node.js applications in TypeScript there are a couple of different approaches you can take.

<!-- TODO: Update code blocks -->

If you're writing your JSON schemas "by hand", you can use the [json-schema-to-ts](https://npm.im/json-schema-to-ts) library to infer TypeScript types from them.

First define your schema:

```typescript
const iceCreamSchema = {
  type: "object",
  properties: {
    flavour: { type: "string" },
    price: { type: "number" },
    stock: { type: "number" },
  },
  required: ["flavour", "price", "stock"],
} as const;
```

Then use `json-schema-to-ts` to infer a type from it:

```typescript
import { FromSchema } from "json-schema-to-ts";

type IceCream = FromSchema<typeof iceCreamSchema>;

const iceCreamData: IceCream = {
  flavour: "Pistacho",
  price: 1.99,
  stock: null,
};
```

The inferred type you get from the code above is equivalent to this type definition:

```typescript
type IceCream = {
  flavour: string;
  price: number;
  stock: number;
};
```

<!-- TODO: Reword -->
As the `stock` property is `null` in the `iceCreamData` object, the TypeScript compiler will raise an error: `Type 'null' is not assignable to type 'number'`.

If you prefer to have schema generation and type inference all in one, you can use the [TypeBox](https://npm.im/@sinclair/typebox) library. First you define your schema using TypeBox's `Type` methods:

```typescript
import { Static, Type } from "@sinclair/typebox";

const iceCreamSchema = Type.Object({
  flavour: Type.String(),
  price: Type.Number(),
  stock: Type.Number(),
});
```

Then you can infer a type from the schema:

```typescript
type IceCream = Static<typeof iceCreamSchema>;

const iceCreamData: IceCream = {
  flavour: "Pistacho",
  price: 1.99,
  stock: null,
};
```

This gives you the same type and static type checking behaviour that `json-schema-to-ts`
provides, but with schema generation built in as well.

## Further reading

TODO: Pull in from email.

## ‚è≠Ô∏è Next part

[Part 4 ‚Äî Sending back validation errors in an effective response format](../04-validation-error-responses/README.md)
